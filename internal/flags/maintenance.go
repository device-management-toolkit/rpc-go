package flags

import (
	"errors"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"regexp"
	"rpc/internal/amt"
	"rpc/pkg/utils"

	log "github.com/sirupsen/logrus"
)

func (f *Flags) printMaintenanceUsage() string {
	executable := filepath.Base(os.Args[0])
	usage := "\nRemote Provisioning Client (RPC) - used for activation, deactivation, maintenance and status of AMT\n\n"
	usage = usage + "Usage: " + executable + " maintenance COMMAND [OPTIONS]\n\n"
	usage = usage + "Supported Maintenance Commands:\n"
	usage = usage + "  changepassword Change the AMT password. A random password is generated by default. Specify -static to set manually. AMT password is required\n"
	usage = usage + "                 Example: " + executable + " maintenance changepassword -u wss://server/activate\n"
	usage = usage + "  syncclock      Sync the host OS clock to AMT. AMT password is required\n"
	usage = usage + "                 Example: " + executable + " maintenance syncclock -u wss://server/activate\n"
	usage = usage + "  synchostname   Sync the hostname of the client to AMT. AMT password is required\n"
	usage = usage + "                 Example: " + executable + " maintenance synchostname -u wss://server/activate\n"
	usage = usage + "  syncip         Sync the IP configuration of the host OS to AMT Network Settings. AMT password is required\n"
	usage = usage + "                 Example: " + executable + " maintenance syncip -staticip 192.168.1.7 -netmask 255.255.255.0 -gateway 192.168.1.1 -primarydns 8.8.8.8 -secondarydns 4.4.4.4 -u wss://server/activate\n"
	usage = usage + "                 If a static ip is not specified, the ip address and netmask of the host OS is used\n"
	usage = usage + "\nRun '" + executable + " maintenance COMMAND -h' for more information on a command.\n"
	fmt.Println(usage)
	return usage
}

func (f *Flags) handleMaintenanceCommand() (bool, int) {
	//validation section
	if len(f.commandLineArgs) == 2 {
		f.printMaintenanceUsage()
		return false, utils.IncorrectCommandLineParameters
	}

	var errCode int

	task := ""
	switch f.commandLineArgs[2] {
	case "syncclock":
		task = f.handleMaintenanceSyncClock()
	case "synchostname":
		task = f.handleMaintenanceSyncHostname()
	case "syncip":
		task, errCode = f.handleMaintenanceSyncIP()
		if errCode != utils.Success {
			return false, errCode
		}
	case "changepassword":
		task = f.handleMaintenanceSyncChangePassword()
	default:
		f.printMaintenanceUsage()
	}
	if task == "" {
		return false, utils.IncorrectCommandLineParameters
	}
	if f.URL == "" {
		fmt.Print("\n-u flag is required and cannot be empty\n\n")
		f.amtMaintenanceCommand.Usage()
		return false, utils.MissingOrIncorrectURL
	}
	if f.Password == "" {
		fmt.Println("Please enter the current AMT Password: ")
		_, err := fmt.Scanln(&f.Password)
		if f.Password == "" || err != nil {
			fmt.Print("\ncurrent AMT password is required and cannot be empty\n\n")
			f.amtMaintenanceCommand.Usage()
			return false, utils.MissingOrIncorrectPassword
		}
	}
	f.Command = fmt.Sprintf("maintenance --password %s %s", f.Password, task)
	if f.Force {
		f.Command = f.Command + " -f"
	}
	return true, utils.Success
}

func (f *Flags) handleMaintenanceSyncClock() string {
	if err := f.amtMaintenanceSyncClockCommand.Parse(f.commandLineArgs[3:]); err != nil {
		return ""
	}
	return "--synctime"
}

func (f *Flags) handleMaintenanceSyncHostname() string {
	var err error
	if err = f.amtMaintenanceSyncHostnameCommand.Parse(f.commandLineArgs[3:]); err != nil {
		return ""
	}
	amtCommand := amt.NewAMTCommand()
	if f.HostnameInfo.DnsSuffixOS, err = amtCommand.GetOSDNSSuffix(); err != nil {
		log.Error(err)
	}
	f.HostnameInfo.Hostname, err = os.Hostname()
	if err != nil {
		log.Error(err)
		return ""
	} else if f.HostnameInfo.Hostname == "" {
		log.Error("OS hostname is not available")
		return ""
	}
	return "--synchostname"
}

// wrap the flag.Func method signature with the assignment value
func validateIP(assignee *string) func(string) error {
	return func(val string) error {
		if net.ParseIP(val) == nil {
			return errors.New("not a valid ip address")
		}
		*assignee = val
		return nil
	}
}

func (f *Flags) handleMaintenanceSyncIP() (string, int) {
	f.amtMaintenanceSyncIPCommand.Func(
		"staticip",
		"IP address to be assigned to AMT - if not specified, the IP Address of the active OS newtork interface is used",
		validateIP(&f.IpConfiguration.IpAddress))
	f.amtMaintenanceSyncIPCommand.Func(
		"netmask",
		"Network mask to be assigned to AMT - if not specified, the Network mask of the active OS newtork interface is used",
		validateIP(&f.IpConfiguration.Netmask))
	f.amtMaintenanceSyncIPCommand.Func("gateway", "Gateway address to be assigned to AMT", validateIP(&f.IpConfiguration.Gateway))
	f.amtMaintenanceSyncIPCommand.Func("primarydns", "Primary DNS to be assigned to AMT", validateIP(&f.IpConfiguration.PrimaryDns))
	f.amtMaintenanceSyncIPCommand.Func("secondarydns", "Secondary DNS to be assigned to AMT", validateIP(&f.IpConfiguration.SecondaryDns))

	if err := f.amtMaintenanceSyncIPCommand.Parse(f.commandLineArgs[3:]); err != nil {
		// Parse the error message to find the problematic flag.
		// The problematic flag is of the following format '-' followed by flag name and then a ':'
		var errCode int
		re := regexp.MustCompile(`-.*:`)
		switch re.FindString(err.Error()) {
		case "-netmask:":
			errCode = utils.MissingOrIncorrectNetworkMask
		case "-staticip:":
			errCode = utils.MissingOrIncorrectStaticIP
		case "-gateway:":
			errCode = utils.MissingOrIncorrectGateway
		case "-primarydns:":
			errCode = utils.MissingOrIncorrectPrimaryDNS
		case "-secondarydns:":
			errCode = utils.MissingOrIncorrectSecondaryDNS
		default:
			errCode = utils.IncorrectCommandLineParameters
		}
		return "", errCode
	} else if len(f.IpConfiguration.IpAddress) != 0 {
		return "--syncip", utils.Success
	}

	amtLanIfc, err := f.amtCommand.GetLANInterfaceSettings(false)
	if err != nil {
		log.Error(err)
		return "", utils.AMTConnectionFailed
	}

	ifaces, err := f.netEnumerator.Interfaces()
	if err != nil {
		log.Error(err)
		return "", utils.OSNetworkInterfacesLookupFailed
	}

	for _, i := range ifaces {
		if len(f.IpConfiguration.IpAddress) != 0 {
			break
		}
		if i.HardwareAddr.String() != amtLanIfc.MACAddress {
			continue
		}
		addrs, _ := f.netEnumerator.InterfaceAddrs(&i)
		if err != nil {
			continue
		}
		for _, address := range addrs {
			if ipnet, ok := address.(*net.IPNet); ok &&
				ipnet.IP.To4() != nil &&
				!ipnet.IP.IsLoopback() {
				f.IpConfiguration.IpAddress = ipnet.IP.String()
				f.IpConfiguration.Netmask = net.IP(ipnet.Mask).String()
			}
		}
	}

	if len(f.IpConfiguration.IpAddress) == 0 {
		log.Errorf("static ip address not found")
		return "", utils.OSNetworkInterfacesLookupFailed
	}
	return "--syncip", utils.Success
}

func (f *Flags) handleMaintenanceSyncChangePassword() string {
	task := "--changepassword "
	f.amtMaintenanceChangePasswordCommand.StringVar(&f.StaticPassword, "static", "", "specify a new password for AMT")
	if err := f.amtMaintenanceChangePasswordCommand.Parse(f.commandLineArgs[3:]); err != nil {
		return ""
	}
	if f.StaticPassword != "" {
		task += f.StaticPassword
	}
	return task
}
